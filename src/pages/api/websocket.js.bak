import { Server } from 'ws';
import { verifyAuthToken } from '../../lib/auth';
import { processInboundCall } from '../../agents/main-agent';
import { createBooking, registerComplaint, createInquiry, recordFeedback, saveConversation } from '../../utils/db-operations';

// In-memory storage for active conversations
const activeConversations = new Map();

// Initialize WebSocket server
export default function handler(req, res) {
  // Only handle WebSocket connections
  if (req.method !== 'GET') {
    res.status(405).json({ error: 'Method not allowed' });
    return;
  }

  // WebSocket connection upgrade handled by ws
  if (!res.socket.server.wss) {
    // Initialize WebSocket server instance
    const wss = new Server({ noServer: true });
    res.socket.server.wss = wss;

    // Handle WebSocket connections
    wss.on('connection', (ws, req) => {
      console.log('New WebSocket connection established');
      
      // Initialize session data for this connection
      const sessionData = {
        conversationId: `conv-${Date.now()}`,
        customerName: null,
        phoneNumber: null,
        messages: [],
        category: null,
        authorized: false,
        audioChunks: [],
        processingChunk: false,
        lastChunkTime: Date.now(),
        lastTranscriptionTime: 0,
        silenceCounter: 0
      };

      // Handle incoming messages
      ws.on('message', async (message) => {
        try {
          let data;
          
          // Parse message if it's a string
          if (typeof message === 'string' || message instanceof Buffer) {
            try {
              const stringMessage = message.toString();
              if (stringMessage.startsWith('{') && stringMessage.endsWith('}')) {
                data = JSON.parse(stringMessage);
              } else {
                console.warn('Received non-JSON string message');
                return;
              }
            } catch (parseError) {
              console.error('Failed to parse message:', parseError);
              return;
            }
          } else {
            console.warn('Received non-string message type');
            return;
          }
          
          // Handle authentication (for phone calls, this would include phone number)
          if (data.type === 'auth') {
            try {
              const token = data.token;
              sessionData.phoneNumber = data.phoneNumber || 'unknown';
              
              // For phone call integration, token validation would depend on your phone system
              // Simple validation for demo purposes
              if (token) {
                sessionData.authorized = true;
                
                // Store basic information in active conversations
                activeConversations.set(sessionData.conversationId, {
                  phoneNumber: sessionData.phoneNumber,
                  messages: [],
                  startTime: new Date(),
                  lastActivity: Date.now()
                });
                
                // Send success response
                ws.send(JSON.stringify({
                  type: 'auth_success',
                  conversationId: sessionData.conversationId
                }));
              } else {
                ws.send(JSON.stringify({
                  type: 'error',
                  error: 'Invalid authentication token'
                }));
                ws.close();
              }
            } catch (error) {
              console.error('Authentication error:', error);
              ws.send(JSON.stringify({
                type: 'error',
                error: 'Authentication failed: ' + error.message
              }));
              ws.close();
            }
            return;
          }
          
          // Require authorization for other message types
          if (!sessionData.authorized) {
            ws.send(JSON.stringify({
              type: 'error',
              error: 'Unauthorized'
            }));
            return;
          }
          
          // Handle streaming audio chunks
          if (data.type === 'audio_chunk' && data.audio) {
            // Reset silence detection as we received audio
            sessionData.silenceCounter = 0;
            sessionData.lastChunkTime = Date.now();
            
            try {
              // Decode base64 audio
              let base64Audio = data.audio;
              // Remove data URL prefix if present
              if (base64Audio.includes('base64,')) {
                base64Audio = base64Audio.split('base64,')[1];
              }
              
              const audioBuffer = Buffer.from(base64Audio, 'base64');
              sessionData.audioChunks.push(audioBuffer);
              
              // Process chunks if enough data or enough time has passed
              const shouldProcess = 
                !sessionData.processingChunk && 
                (Date.now() - sessionData.lastTranscriptionTime > 500) &&
                sessionData.audioChunks.length >= 2;
              
              if (shouldProcess) {
                await processAudioChunks(ws, sessionData);
              }
            } catch (error) {
              console.error('Error processing audio chunk:', error);
              ws.send(JSON.stringify({
                type: 'error',
                error: 'Failed to process audio: ' + error.message
              }));
            }
            return;
          }
          
          // Handle recording stopped (useful for phone call ending/silence detection)
          if (data.type === 'recording_stopped' || data.type === 'call_ended') {
            // Process any remaining audio chunks
            if (sessionData.audioChunks.length > 0 && !sessionData.processingChunk) {
              await processAudioChunks(ws, sessionData, true);
            }
            
            // If this is a call end, store the conversation
            if (data.type === 'call_ended') {
              try {
                await storeConversation(sessionData);
                
                ws.send(JSON.stringify({
                  type: 'conversation_stored',
                  success: true
                }));
                
                // Clean up
                activeConversations.delete(sessionData.conversationId);
              } catch (error) {
                console.error('Error storing conversation:', error);
                ws.send(JSON.stringify({
                  type: 'error',
                  error: 'Failed to store conversation: ' + error.message
                }));
              }
            }
            return;
          }
        } catch (error) {
          console.error('WebSocket message error:', error);
          ws.send(JSON.stringify({
            type: 'error',
            error: 'Invalid message format: ' + error.message
          }));
        }
      });
      
      // Set up silence detection for phone calls
      const silenceCheckInterval = setInterval(() => {
        if (sessionData.authorized && sessionData.lastChunkTime) {
          const timeSinceLastChunk = Date.now() - sessionData.lastChunkTime;
          
          // If no audio for more than 2 seconds, consider it silence
          if (timeSinceLastChunk > 2000) {
            sessionData.silenceCounter++;
            
            // After 3 consecutive silence checks (6s total), process remaining audio
            if (sessionData.silenceCounter >= 3 && sessionData.audioChunks.length > 0 && !sessionData.processingChunk) {
              console.log('Silence detected in call, processing remaining audio');
              processAudioChunks(ws, sessionData, true);
            }
          } else {
            sessionData.silenceCounter = 0;
          }
        }
      }, 2000);
      
      // Handle disconnection
      ws.on('close', () => {
        console.log('WebSocket connection closed');
        
        // Clean up interval
        clearInterval(silenceCheckInterval);
        
        // Store the conversation if it has content
        if (sessionData.messages.length > 0) {
          storeConversation(sessionData)
            .then(() => console.log(`Stored conversation on disconnect: ${sessionData.conversationId}`))
            .catch(err => console.error(`Failed to store conversation on disconnect: ${err.message}`));
        }
        
        // Clean up any other resources
        if (sessionData.conversationId) {
          // Set a timeout to delete after some period of inactivity
          setTimeout(() => {
            if (activeConversations.has(sessionData.conversationId)) {
              activeConversations.delete(sessionData.conversationId);
            }
          }, 30 * 60 * 1000); // 30 minutes
        }
      });
    });
    
    // Handle WebSocket upgrade
    res.socket.server.on('upgrade', (request, socket, head) => {
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit('connection', ws, request);
      });
    });
  }
  
  // End the response for the initial HTTP request
  res.end();
}

/**
 * Process audio chunks and respond with transcription
 * @param {WebSocket} ws - WebSocket connection 
 * @param {Object} sessionData - Session data for the current connection
 * @param {boolean} isFinal - Whether this is the final chunk for the utterance
 */
async function processAudioChunks(ws, sessionData, isFinal = false) {
  if (sessionData.processingChunk) return;
  
  try {
    sessionData.processingChunk = true;
    
    // Combine audio chunks
    const combinedAudio = Buffer.concat(sessionData.audioChunks);
    sessionData.audioChunks = []; // Clear chunks
    
    // Skip processing if audio is too small
    if (combinedAudio.length < 100) {
      console.log('Audio too small, skipping processing');
      sessionData.processingChunk = false;
      return;
    }
    
    // Process audio with main agent
    const result = await processInboundCall(
      combinedAudio,
      sessionData.phoneNumber,
      [] // No conversation history needed since we track in session
    );
    
    // Update session data
    sessionData.lastTranscriptionTime = Date.now();
    
    // Only send response if we have meaningful transcribed text
    if (result.transcribedText && result.transcribedText.trim()) {
      // Add to conversation history
      sessionData.messages.push({
        role: 'user',
        content: result.transcribedText,
        timestamp: new Date().toISOString()
      });
      
      // Send transcription to web client
      ws.send(JSON.stringify({
        type: 'transcription',
        text: result.transcribedText
      }));
      
      // Only respond if this is final chunk or significant text
      if (isFinal || result.transcribedText.length > 15) {
        // Add agent response to conversation history
        sessionData.messages.push({
          role: 'assistant',
          content: result.response,
          timestamp: new Date().toISOString()
        });
        
        // Update customer information
        if (result.customerName) {
          sessionData.customerName = result.customerName;
        }
        
        if (result.category) {
          sessionData.category = result.category;
        }
        
        if (result.service) {
          sessionData.service = result.service;
        }
        
        if (result.dbActionResult) {
          sessionData.dbActionResult = result.dbActionResult;
        }
        
        // Send response to web client
        ws.send(JSON.stringify({
          type: 'response',
          text: result.response
        }));
        
        // Send audio response if available
        if (result.audioResponse) {
          // For web interface - send base64 encoded audio
          ws.send(JSON.stringify({
            type: 'audio',
            data: result.audioResponse.toString('base64')
          }));
          
          // For actual phone integration - you would send the audio to the phone system
          // Example: telephonyAPI.sendAudio(sessionData.callSid, result.audioResponse);
        }
      }
    }
    
    // Update conversation in active conversations map
    const conversation = activeConversations.get(sessionData.conversationId);
    if (conversation) {
      conversation.lastActivity = Date.now();
      if (sessionData.messages.length > conversation.messages.length) {
        conversation.messages = sessionData.messages;
      }
      if (sessionData.category) {
        conversation.category = sessionData.category;
      }
      activeConversations.set(sessionData.conversationId, conversation);
    }
  } catch (error) {
    console.error('Error processing audio chunks:', error);
    ws.send(JSON.stringify({
      type: 'error',
      error: 'Failed to process audio: ' + error.message
    }));
  } finally {
    sessionData.processingChunk = false;
  }
}

/**
 * Store conversation in the database
 * @param {Object} sessionData - Session data with conversation details
 */
async function storeConversation(sessionData) {
  if (!sessionData || !sessionData.messages || sessionData.messages.length === 0) {
    throw new Error('No conversation data to store');
  }
  
  try {
    // Create full transcript from messages
    const fullTranscript = sessionData.messages.map(m => 
      `[${m.timestamp || new Date().toISOString()}] ${m.role}: ${m.content}`
    ).join('\n');
    
    // Determine query type based on category
    const queryType = sessionData.category || 'inquiry';
    
    // For demo purposes - in real implementation you'd connect to your telephony system's call data
    const callData = {
      customerName: sessionData.customerName || 'Unknown Caller',
      phoneNumber: sessionData.phoneNumber,
      queryType: queryType,
      sourceId: sessionData.dbActionResult?.id || 0,
      transcript: fullTranscript,
      service: sessionData.service || 'general',
      interactionDate: new Date(),
      time: new Date().toTimeString().split(' ')[0],
      summary: sessionData.messages.length > 0 ? 
        sessionData.messages[sessionData.messages.length - 1].content : 'No summary available'
    };
    
    // Save conversation to database
    const result = await saveConversation(callData);
    return result;
  } catch (error) {
    console.error('Error storing conversation:', error);
    throw error;
  }
} 